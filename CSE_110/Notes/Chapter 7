# Chapter 7 

## 7.1 - User-defined method basics
### Methods (general)
    A program may perform the same operation repeatedly, causing a large and confusing program due to redundancy. Program redundancy can be reduced by creating a grouping of predefined statements for repeatedly used operations, known as a method. Even without redundancy, methods can prevent a main program from becoming large and confusing.


Basics of methods
    A method is a named list of statements.
        A method definition consists of the new method's name and a block of statements. Ex: public static double calcPizzaArea() { /* block of statements */ }
        A method call is an invocation of a method's name, causing the method's statements to execute.
The method's name can be any valid identifier. A block is a list of statements surrounded by braces. 


### Parameters
    A programmer can influence a method's behavior via an input.
        A parameter is a method input specified in a method definition. Ex: A pizza area method might have diameter as an input.
        An argument is a value provided to a method's parameter during a method call. Ex: A pizza area method might be called as printPizzaArea(12.0) or as printPizzaArea(16.0).
A parameter is like a variable declaration. Upon a call, the parameter's memory location is allocated, and the parameter is assigned with the argument's value. Upon returning to the original call location, the parameter is deleted from memory.

An argument may be an expression, like 12.0, x, or x * 1.5.

## 7.2 - Define Methods with No Parameters and Return Value

### Defining Simple Methods

    We have seen some examples of how to call methods previously, and we have taken a look at some of the many methods already available to us in the Java standard library. Now we will learn how to define our own methods! Defining a method is a way to specify how an operation or computation is to be done, and to name that operation or computation.

    We will start with a simple method that takes no arguments and returns no value. Such methods are useful for simple repetitive tasks. Say for example, that you would like to display a little ACSII art bunny on the terminal window. You could write some code like this:

    System.out.println(" (\\(\\   ");
    System.out.println(" (-.-)    ");
    System.out.println(" O_(\")(\") ");

    ***If there is not already a method to do what we want, then we should define a method to do it.***
            Idea is if we have to call it more than once then define it in its own method so you can repeat the call without recreating everything for bunny above.
    
    So, how do we define a method?
    Here's the basic syntax for defining a method in Java.

### Syntax of Simple Methods:
public static <returnType> <methodName>(<parameterList>) {
<methodBody>
}

Notice that a method definition may include some access modifiers which will be discussed in more detail later. We will be using the public static access modifiers for now. A method definition will always have these parts:

    <returnType> - the type of value this method will return
    <methodName> - the name for this list of instructions
    (<parameterList>) - describing the arguments that must be passed to this method
    {<methodBody>} - the list of instructions to execute when this method is called

Here is an example, defining a method named printBunny.

public static void printBunny() {
   print(" (\\(\\   ")
   print(" (-.-)    ")
   print(" O_(\")(\") ")
}

Note that the return type void means that this method does not return any value. This method does print something to the terminal window when you call it, but it does not return anything. The method's name is printBunny. Also note that the parameter list for this method definition is empty (); this means that you will not pass any arguments to this method when you call it. Finally note, that the method body is always contained inside of a pair of curly braces { }.

*** Example of this at Code: AnimalsPrint.java & it's .class as well ***

## 7.3 - Define Methods with Parameters

Defining a Method that Takes an Argument
    We can also define methods that have inputs (i.e. methods that take arguments). It is quite simple to define a method that takes an argument. We just need to include a parameter variable for the argument value in the method's parameter list.

### Code Example:

public class Greeting {
   public static void main(String[] args) {
      sayHello("Chen");
      sayHello("Bobby");
      sayHello("Ahmed");

      String myName = "Deepa";
      sayHello(myName);
   } 

   public static void sayHello(String firstName) {
      System.out.println("Hello " + firstName + "!");
   }
}

## 7.5
    
**Modular and incremental program development**

Programmers commonly use methods to write programs modularly and incrementally.

    Modular development is the process of dividing a program into separate modules that can be developed and tested separately and then integrated into a single program.
    Incremental development is a process in which a programmer writes, compiles, and tests a small amount of code, then writes, compiles, and tests a small amount more (an incremental amount), and so on.
    A method stub is a method definition whose statements have not yet been written.

A programmer can use method stubs to capture the high-level behavior of main() and the required method (or modules) before diving into details of each method, like planning a route for a road trip before starting to drive. A programmer can then incrementally develop and test each method independently.



**Avoid writing redundant code**

A method can be defined once, then called from multiple places in a program, thus avoiding redundant code. Examples of such methods are math methods like abs() that relieve a programmer from having to write several lines of code each time an absolute value needs to be computed.

The skill of decomposing a program's behavior into a good set of methods is a fundamental part of programming that helps characterize a good programmer. Each method should have easily-recognizable behavior, and the behavior of main() (and any method that calls other methods) should be easily understandable via the sequence of method calls.

A general guideline (especially for beginner programmers) is that a method's definition usually shouldn't have more than about 30 lines of code, although this guideline is not a strict rule.



## 7.7 What Can we Do with a Method?
B V
There are really the only two things you can do with a method:

    Define it
    Call it

The power of methods comes from how we use them. We use methods to simplify the design, construction, testing, and debugging of programs. This simplification is possible because methods allow us to:

    Name operations (the things a program does)
    Break a complex algorithm down into simple pieces of functionality
    Build complex programs out of simple pieces

We want to use methods:

    When similar code appears more than once in a program
    When a sequence of instructions is long or overly complex

## 7.8 Method name overloading

Sometimes a program has two methods with the same name but differing in the number or types of parameters, known as method name overloading or just method overloading. The following two methods print a date given the day, month, and year. The first method has parameters of type int, int, and int, while the second has parameters of type int, string, and int. 


The compiler determines which method to call based on the argument types. datePrint(30, 7, 2012) has argument types int, int, int, so calls the first method. datePrint(30, "July", 2012) has argument types int, string, int, so calls the second method.

More than two same-named methods is allowed as long as each has distinct parameter types. Thus, in the above program:

    datePrint(int month, int day, int year, int style) can be added because the types int, int, int, int differ from int, int, int, and from int, string, int.
    datePrint(int month, int day, int year) yields a compiler error, because two methods have types int, int, int (the parameter names are irrelevant).

A method's return type does not influence overloading. Thus, having two same-named method definitions with the same parameter types but different return types still yield a compiler error. 
