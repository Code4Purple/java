
--------------------------------------------------
                    9.1
--------------------------------------------------
-------------------------
    Methods (general)
-------------------------

A program may perform the same operation repeatedly, causing a large and confusing program due to redundancy. 
Program redundancy can be reduced by creating a grouping of predefined statements for repeatedly used operations, 
known as a method. Even without redundancy, methods can prevent a main program from becoming large and confusing.

-------------------------
    Basics of methods
-------------------------

A method is a named list of statements.
    A method definition consists of the new method's name and a block of statements. Ex: public static double calcPizzaArea() { /* block of statements */ }
    A method call is an invocation of a method's name, causing the method's statements to execute.

The method's name can be any valid identifier. A block is a list of statements surrounded by braces.

Below, the method call calcPizzaArea() causes execution to jump to the method's statements. Execution returns to the original location after executing 
the method's last statement.

Methods must be defined within a class. The line: public class PizzaArea {  begins a new class. \
The class has two methods, calcPizzaArea() and main(). Both use the access modifiers public static. public indicates the method may 
be called from any class in the program, and static indicates the method only uses values that are passed to the method; details of access modifiers are discussed elsewhere. 
For now, just know that a method defined using public static can be called from the program's main() method

--------------------------------------
    Returning a value from a method
--------------------------------------

A method may return one value using a return statement. Below, the computeSquare() method is defined to have a return type of int; 
thus, the method's return statement must have an expression that evaluates to an int.

-----------------------------
        Parameters
-----------------------------

A programmer can influence a method's behavior via an input.

    A parameter is a method input specified in a method definition. Ex: A pizza area method might have diameter as an input.
    
    An argument is a value provided to a method's parameter during a method call. Ex: A pizza area method might be called as 
    calcPizzaArea(12.0) or as calcPizzaArea(16.0).

A parameter is like a variable declaration. Upon a call, the parameter's memory location is allocated, and the parameter is assigned with the argument's value. 
Upon returning to the original call location, the parameter is deleted from memory.

An argument may be an expression, like 12.0, x, or x * 1.5.

--------------------------------------------
        Multiple or no parameters
--------------------------------------------

A method definition may have multiple parameters, separated by commas. 
Parameters are assigned with argument values by position: First parameter with first argument, second with second, etc.

A method definition with no parameters must still have the parentheses, as in: int doSomething() { ... }. 
The call must include parentheses, with no argument, as in: doSomething().

-------------------------------------------
        Calling methods from methods
-------------------------------------------

A method's statements may call other methods. In the example below, the pizzaCalories() method calls the calcCircleArea() method. 
(Note that main() itself is the first method called when a program executes, and calls other methods.)


-------------------------------------------
                9.2
-------------------------------------------

---------------------------------
    Printing from a method
---------------------------------

A common operation for a method is to print text. Large text outputs can clutter the main() method of a 
program, especially if the text needs to be output multiple times. A method that only prints typically does 
not return a value. The void keyword indicates a method does not return a value. A method with a void return 
type is often called a void method. Once a void method finishes execution, control returns back to the caller 
and no value is returned.

---------------------------------------------------
    Calling a print method multiple times
---------------------------------------------------

One benefit of a print method is that complex output statements can be written in code once. 
Then the print method can be called multiple times to produce the output instead of rewriting complex 
statements for every necessary instance. Changes to output and formatting are made easier and are less prone 
to error.

----------------------------------------------------
                9.3
----------------------------------------------------

------------------------------------
    Defining Simple Methods
------------------------------------

We have seen some examples of how to call methods previously, and we have taken a look at some of the many 
methods already available to us in the Java standard library. Now we will learn how to define our own methods! 
Defining a method is a way to specify how an operation or computation is to be done, and to name that operation 
or computation.

We will start with a simple method that takes no arguments and returns no value. 
Such methods are useful for simple repetitive tasks. Say for example, that you would like to display a 
little ACSII art bunny on the terminal window. You could write some code like this:

System.out.println(" (\\(\\   ");
System.out.println(" (-.-)    ");
System.out.println(" O_(\")(\") ");

When you run this code it will display a sequence of characters that looks kind of like a little bunny.

Idea behind this method of thinking : If there is not already a method to do what we want, then we should define a method to do it.


--------------------------------------------------------
                9.4
--------------------------------------------------------

Arguments are the values passed to methods

---------------------
    example
---------------------

public static void sayHello(String firstName) {
    System.out.println("Hello " + firstName + "!");
}

Parameters are the variables that receive and store the values passed to methods.

Parameters Variables are assigned values in the order that the arguments are listed.


----------------------------------------------------------
                9.5
-----------------------------------------------------------

Modular and incremental program development

Programmers commonly use methods to write programs modularly and incrementally.

    Modular development is the process of dividing a program into separate modules that can be developed and tested separately and then integrated into a single program.
    Incremental development is a process in which a programmer writes, compiles, and tests a small amount of code, then writes, compiles, and tests a small amount more (an incremental amount), and so on.
    A method stub is a method definition whose statements have not yet been written.

A programmer can use method stubs to capture the high-level behavior of main() and the required method (or modules) before diving into details of each method, like planning a route for a road trip before starting to drive. 
A programmer can then incrementally develop and test each method independently.


---------------------------------------------------------------
                9.8
---------------------------------------------------------------

-------------------------------------------
    What can we do with a method?
-------------------------------------------

There are really the only two things you can do with a method:
    Define it
    Call it

The power of methods comes from how we use them. We use methods to simplify the design, construction, testing, and debugging of programs. 
This simplification is possible because methods allow us to:
    Name operations (the things a program does)
    Break a complex algorithm down into simple pieces of functionality
    Build complex programs out of simple pieces

We want to use methods:
    When similar code appears more than once in a program
    When a sequence of instructions is long or overly complex

--------------------------------------------------------------------------
                9.13.1: Validate domain names with methods.
---------------------------------------------------------------------------

Methods facilitate breaking down a large problem into a collection of smaller ones.

A top-level domain (TLD) name is the last part of an Internet domain name like .com in example.com. 
A core generic top-level domain (core gTLD) is a TLD that is either .com, .net, .org, or .info. 
A restricted top-level domain is a TLD that is either .biz, .name, or .pro. A second-level domain is a single name that precedes a TLD as in apple in apple.com

The following program repeatedly prompts for a domain name and indicates whether that domain name is valid and has a core gTLD. For this program, 
a valid domain name has a second-level domain followed by a TLD, and the second-level domain has these three characteristics:

    1. Is 1-63 characters in length.
    2. Contains only uppercase and lowercase letters or a dash.
    3. Does not begin or end with a dash.

For this program, a valid domain name must contain only one period, such as apple.com, but not support.apple.com. 
The program ends when the user presses just the Enter key in response to a prompt.

    1. Run the program. Note that a restricted gTLD is not recognized as such.
    2. Change the program by writing an input method and adding the validation for a restricted gTLD. Run the program again.


-------------------------------------------------------------------------------------
                9.14
-------------------------------------------------------------------------------------

Sometimes a program has two methods with the same name but differing in the number or types of parameters, 
known as method name overloading or just method overloading. The following two methods print a date given the 
day, month, and year. The first method has parameters of type int, int, and int, while the second has parameters 
of type int, string, and int. 

The compiler determines which method to call based on the argument types. printDate(30, 7, 2012) has argument 
types int, int, int, so calls the first method. printDate(30, "July", 2012) has argument types int, string, int, 
so calls the second method.

More than two same-named methods is allowed as long as each has distinct parameter types. Thus, in the above program:

    printDate(int month, int day, int year, int style) can be added because the types int, int, int, int differ from int, int, int, and from int, string, int.
    printDate(int month, int day, int year) yields a compiler error, because two methods have types int, int, int (the parameter names are irrelevant).

A method's return type does not influence overloading. Thus, having two same-named method definitions with the same parameter types but different return types still yield a compiler error. 


-------------------------------------------------------------------------------------
                9.15
--------------------------------------------------------------------------------------

Each method call creates a new set of local variables, forming part of what is known as a stack frame. 
A return causes those local variables to be discarded. 

Some knowledge of how a method call and return works at the bytecode level can not only satisfy curiosity, 
but can also lead to fewer mistakes when parameter and return items become more complex. 
The following animation illustrates by showing, for a method named findMax(), some sample high-level code, 
compiler-generated bytecode instructions in memory, and data in memory during runtime. This animation presents 
advanced material intended to provide insight and appreciation for how a method call and return works.

The compiler generates instructions to copy arguments to parameter local variables, and to store a return address. 
A jump instruction jumps from main to the method's instructions. The method executes and stores results in a 
designated return value location. When the method completes, an instruction jumps back to the caller's location 
.using the previously-stored return address. Then, an instruction copies the method's return value to the appropriate variable.

-----------------------------------------------------------------------------------------
                9.17 Using Scanner in methods
-----------------------------------------------------------------------------------------
-----------------------
    Instructor note:
-----------------------

Note that the code below (Use a single Scanner to read input) includes an if statement. While we have not yet covered this logic structure, all you need to understand is that an if statement is how we can get the computer to make a decision.

If some expression (like scnr.hasNext()) evaluates to true then the directly following block { name = scnr.next(); } will execute, otherwise that block will be skipped.

We will cover if statements and decision logic in detail in the next chapter.

------------------------------------------
        Passing Scanner to methods
------------------------------------------

A program should only use one Scanner per input stream. Internally, a Scanner object may read more input than needed to make subsequent reads faster. Thus, using multiple Scanners for the same input stream may lead to unexpected results.

If a method needs to read user input, a good practice is to create a single Scanner object in main() and pass that Scanner object to the method. The program below creates a Scanner object in main() and passes the Scanner to the getPizzaCalories() method.

